const debugAPI = require('debug')('api'),
    { validationResult } = require('express-validator/check'),
    mongoose = require('mongoose'),
    GoogleCloudStorage = require('@google-cloud/storage'),
    sharp = require('sharp'),
    fs = require('fs'),
    loggly = require('./logger').loggly


// NO CACHE ON SHARP
sharp.cache(false);

// GOOGLE STORAGE
var Gstorage = new GoogleCloudStorage({
    projectId: 'ionic-test-1-3eb9b',
    keyFilename: './config/google-ionic-service-keys.json'
})
const GSBucket = Gstorage.bucket('ionic-test-1-3eb9b.appspot.com');

const invalidChars = '+×÷=%_€£¥₩§!@#$/^&*()-:;,?`´^~\'\"\\|ºª<>{}[]°•○●□■♤♡◇♧☆▪¤《》¡¿'.split('') // Basic char blacklist
const invalidCharsNumbers = invalidChars.concat('1234567890'.split(''))


// apiHandler class gets initialized for each request
class apiHandler {

    // CUSTOM ERROR CODES:
    // 4000 - random custom error
    // 4001 - no such user
    // 4002 - invalid token
    // 4003 - invalid uid 
    // 4004 - user not loggedin
    // 4005 - validation error
    // 5000 - internal server error
    // 5001 - upload failed

    constructor(req, res) {
        this.req = req; // req contains req.id, generated by 'express-request-id';
        this.res = res;
        this.req_id = req.id;
        this.logs = [] // Group all logs throughtout the request life and send them all in the end (response, success, or error), along with response data
        this.hrstart = process.hrtime()
        console.log("New API call...")
        this.logRequestLocal()
    }
    
    logRequestLocal() {
        let reqlog = this.getReqLog()
        console.log(`\n ---------------- ${reqlog.method} ${reqlog.path} UID: ${this.req.params.uid} ----------------`)
        console.log('REQUEST: ', this.req.body)
    }
    logLogglySuccess(reqlog, reslog, exectime_ms){
        loggly.info('API response',{ request: reqlog, response: reslog, exectime_ms: exectime_ms, logs: this.logs })
    }
    logLogglyError(reqlog, errorlog, exectime_ms){
        loggly.error('API error',{ request: reqlog, error: errorlog, exectime_ms: exectime_ms, logs: this.logs })
    }
    log(message, arg) {
        console.log(message, arg) // Log to console right away
        this.logs.push({arg, message}) // Push to logs to send to loggly in the end
    }

    getExecms(){
        let hrdiff = process.hrtime(this.hrstart)
        let exectime_ms = Math.ceil(hrdiff[0]*1000 + hrdiff[1]/1000/1000)
        return exectime_ms
    }

    getReqLog() {
        let reqlog = {
            method: this.req.method,
            path: this.req.path,
            req_id: this.req.id,
            uid: this.req.params.uid,
            body: this.req.body
        }
        return reqlog
    }

    checkValidation() {
        // Check for errors from express-validator
        const errors = validationResult(this.req);
        if (!errors.isEmpty()) {
            this.validationError(errors.array())
            return true
        } else {
            return false
        }
    }

    validationError(errors, message, error_code = 4005) {
        // Errors in an array from express-validator
        let reqlog = this.getReqLog()
        let errorlog = {
            type: 'validation error',
            errors: errors,
            error_code,
            message: message,
        }
        this.logLogglyError(reqlog, errorlog, this.getExecms())
        console.log(`VALIDATION ERROR: `, errors)

        this.res.status(400).json({
            type: "validation error",
            success: false,
            errors: errors,
            error_code: error_code,
            message: message,
            req_id: this.req_id
        })
    }

    error(error, message, error_code = null) {
        if (typeof error == 'string') { // Custom error, thrown to be shown to client
            error_code = error_code || 4000
            message = message || error; // If custom message, use it, otherwise show error
            this.res.status(400).json({
                type: 'error',
                success: false,
                error: error,
                error_code: error_code,
                message: message,
                req_id: this.req_id
            })
        } else { // Server error
            message = message || 'Internal server error'
            error_code = error_code || 5000
            this.res.status(500).json({
                type: 'server error',
                success: false,
                error: 'internal server error',
                error_code: 5000,
                message: message,
                req_id: this.req_id
            })
        }

        let reqlog = this.getReqLog()        
        let errorlog = {
            type: 'error',
            error_code: error_code,
            stack: error.stack,
            message: error.message
        }
        console.log(`ERROR: `, error, message)
        this.logLogglyError(reqlog, errorlog, this.getExecms())
    }

    respond(data, message = null) {
        let reqlog = this.getReqLog()
        let reslog = {
            type: 'response',
            success: true,
            data: data,
            message
        }
        this.logLogglySuccess(reqlog, reslog, this.getExecms())
        console.log(`RESPONSE: `, data, message)

        this.res.status(200).json({
            type: 'response',
            success: true,
            message,
            data,
            req_id: this.req_id
        })
    }

    success(message) {
        let reqlog = this.getReqLog()
        let reslog = {
            type: 'success',
            success: true,
            message
        }
        console.log(`SUCCESS: `, message)
        this.logLogglySuccess(reqlog, reslog, this.getExecms())

        this.res.status(200).json({
            type: 'success',
            success: true,
            message,
            req_id: this.req_id
        })
    }

    nosuchuser() {
        this.error('Conta não existente', '', 4001)
    }

    userNotLoggedIn() {
        this.error('not logged in', '', 4004)
    }

    invalidToken() {
        this.error('invalid token', '', 4002)
    }

    invalidUID() {
        this.error('invalid uid', '', 4003)
    }
}

module.exports.apiHandler = apiHandler
module.exports.initApiHandler = function(req, res, next){
    const api = new apiHandler(req, res)
    api.logRequestLocal()
    req.api = api;
    next()
}
module.exports.checkMongoID = uid => {
    if (mongoose.Types.ObjectId.isValid(uid)) {
        return true
    } else {
        return false
    }
}

module.exports.cleanString = (string, clean_numbers = false) => {
    const blacklist = clean_numbers ? invalidCharsNumbers : invalidChars
    const filtered = string.split('').filter(char => {
        return !blacklist.includes(char)
    })
    return filtered.join('').trim()
}

function uploadToGS(localFileLocation) {
    return GSBucket.upload(localFileLocation, { public: true }).then(file => {
        return file[0].metadata.mediaLink
    })
}
module.exports.uploadToGS = uploadToGS
module.exports.uploadAvatar = async (file) => {
    const filepath = file.path
    const filename = file.filename.split('.')[0]

    // Resize
    let p_resize1 = sharp(filepath).resize(600, 600).toFile(`uploads/resized/${filename}-lg.jpeg`)
    let p_resize2 = sharp(filepath).resize(250, 250).toFile(`uploads/resized/${filename}-md.jpeg`)
    let p_resize3 = sharp(filepath).resize(80, 80).toFile(`uploads/resized/${filename}-sm.jpeg`)

    await Promise.all([p_resize1, p_resize2, p_resize3])

    // Upload to Gstorage
    let p_store1 = uploadToGS(`./uploads/resized/${filename}-lg.jpeg`)
    let p_store2 = uploadToGS(`./uploads/resized/${filename}-md.jpeg`)
    let p_store3 = uploadToGS(`./uploads/resized/${filename}-sm.jpeg`)

    let urls = await Promise.all([p_store1, p_store2, p_store3])
    urls = {
        sm: urls[2],
        md: urls[1],
        lg: urls[0]
    }
    console.log("URLS: ",urls)

    // Delete photos after upload

    function deleteCB(err) {
        if(err){
            throw err
        }
    }
    fs.unlink(filepath, deleteCB)
    fs.unlink(`./uploads/resized/${filename}-lg.jpeg`, deleteCB)
    fs.unlink(`./uploads/resized/${filename}-md.jpeg`, deleteCB)
    fs.unlink(`./uploads/resized/${filename}-sm.jpeg`, deleteCB)

    return urls
}
